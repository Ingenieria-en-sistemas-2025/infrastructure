name: Deploy infra (all services)

on:
  push:
    branches: [ "dev", "main" ]
  workflow_dispatch: {}

jobs:
  validate:
    name: Validate compose/env by branch
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Basic files check
        run: |
          test -f docker-compose.yml || (echo "docker-compose.yml no encontrado" && exit 1)
          echo "OK: .env no es requerido en el repo (se genera en la VM)."

      - name: Validate tags per branch (latest vs dev-latest)
        run: |
          echo "Branch: ${{ github.ref_name }}"
          if [ "${{ github.ref_name }}" = "main" ]; then
            # En PROD no debe haber dev-latest en archivos del repo
            ! grep -R "dev-latest" -n docker-compose.yml . || (echo "main no puede usar dev-latest" && exit 1)
          elif [ "${{ github.ref_name }}" = "dev" ]; then
            # En DEV no forzamos .env; se genera en deploy
            true
          else
            echo "Rama no soportada para despliegue" && exit 1
          fi

      - name: Print resolved compose
        shell: bash
        run: |
          if [ -f .env ]; then
            echo "Usando .env presente (solo para inspecciÃ³n local):"
            docker compose --env-file .env config || true
          else
            echo "No hay .env (correcto para repo). Mostrando config con variables sin expandir:"
            docker compose config || true
          fi

  deploy:
    name: Deploy to target VM
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Start DEV VM
        if: github.ref_name == 'dev'
        run: |
          az vm start -g "${{ secrets.AZ_RG_DEV }}" -n "${{ secrets.AZ_VM_DEV_NAME }}"
          for i in {1..24}; do nc -z ${{ secrets.VM_DEV_HOST }} 22 && exit 0; sleep 5; done; exit 1

      - name: Start PROD VM
        if: github.ref_name == 'main'
        run: |
          az vm start -g "${{ secrets.AZ_RG_PROD }}" -n "${{ secrets.AZ_VM_PROD_NAME }}"
          for i in {1..24}; do nc -z ${{ secrets.VM_PROD_HOST }} 22 && exit 0; sleep 5; done; exit 1

      - name: Deploy to DEV (all)
        if: github.ref_name == 'dev'
        uses: appleboy/ssh-action@v1.0.3
        env:
          GHCR_USER: ${{ secrets.GHCR_USER }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          SNIPPETS_DB_USER: ${{ secrets.SNIPPETS_DB_USER }}
          SNIPPETS_DB_PASS: ${{ secrets.SNIPPETS_DB_PASS }}
          TESTS_DB_USER: ${{ secrets.TESTS_DB_USER }}
          TESTS_DB_PASS: ${{ secrets.TESTS_DB_PASS }}
        with:
          host: ${{ secrets.VM_DEV_HOST }}
          username: ${{ secrets.VM_SSH_USER }}
          key: ${{ secrets.VM_DEV_SSH_KEY }}
          script: |
            set -e
            cd ~/infrastructure
            git fetch --all
            git checkout dev || true
            git pull || true
            
            cat > .env <<'EOF'
            SNIPPETS_IMAGE=ghcr.io/ingenieria-en-sistemas-2025/printscript-snippets
            EXECUTION_IMAGE=ghcr.io/ingenieria-en-sistemas-2025/printscript-execution
            TESTS_IMAGE=ghcr.io/ingenieria-en-sistemas-2025/printscript-tests

            SNIPPETS_TAG=dev-latest
            EXECUTION_TAG=dev-latest
            TESTS_TAG=dev-latest

            SNIPPETS_DB_USER=${SNIPPETS_DB_USER}
            SNIPPETS_DB_PASS=${SNIPPETS_DB_PASS}
            TESTS_DB_USER=${TESTS_DB_USER}
            TESTS_DB_PASS=${TESTS_DB_PASS}
            EOF
            
            
            if [ -n "${GHCR_USER}" ] && [ -n "${GHCR_PAT}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
            fi
            docker network create printscript-net || true
            docker compose pull
            docker compose up -d --remove-orphans
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Ports}}"
            docker image prune -f
            chmod 600 .env || true

      - name: Deploy to PROD (all)
        if: github.ref_name == 'main'
        uses: appleboy/ssh-action@v1.0.3
        env:
          GHCR_USER: ${{ secrets.GHCR_USER }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          SNIPPETS_DB_USER: ${{ secrets.SNIPPETS_DB_USER }}
          SNIPPETS_DB_PASS: ${{ secrets.SNIPPETS_DB_PASS }}
          TESTS_DB_USER: ${{ secrets.TESTS_DB_USER }}
          TESTS_DB_PASS: ${{ secrets.TESTS_DB_PASS }}
        with:
          host: ${{ secrets.VM_PROD_HOST }}
          username: ${{ secrets.VM_SSH_USER }}
          key: ${{ secrets.VM_PROD_SSH_KEY }}
          script: |
            set -e
            cd ~/infrastructure
            git fetch --all
            git checkout main || true
            git pull || true
            
            cat > .env <<'EOF'
            SNIPPETS_IMAGE=ghcr.io/ingenieria-en-sistemas-2025/printscript-snippets
            EXECUTION_IMAGE=ghcr.io/ingenieria-en-sistemas-2025/printscript-execution
            TESTS_IMAGE=ghcr.io/ingenieria-en-sistemas-2025/printscript-tests

            SNIPPETS_TAG=latest
            EXECUTION_TAG=latest
            TESTS_TAG=latest

            SNIPPETS_DB_USER=${SNIPPETS_DB_USER}
            SNIPPETS_DB_PASS=${SNIPPETS_DB_PASS}
            TESTS_DB_USER=${TESTS_DB_USER}
            TESTS_DB_PASS=${TESTS_DB_PASS}
            EOF
            
            
            if [ -n "${GHCR_USER}" ] && [ -n "${GHCR_PAT}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
            fi
            
            docker network create printscript-net || true
            docker compose pull
            docker compose up -d --remove-orphans
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Ports}}"
            docker image prune -f
            chmod 600 .env || true